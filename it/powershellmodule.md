# PowerShell Module Structure

PowerShell modules at their most basic are just a psm1 file with a bunch of functions.  The file is
imported into a PowerShell sessions and then the functions can be called.  From there, the module
can expand and become more useful.

The next step is to have a module manifest whose file type is psd1 and contains a structure hash
table with meta data about the module such as the name, version and public functions to make
available from the associated psm1 file when the module is imported.

From there, the person authoring the module has a decision to make, either keep all the functions in
the monolithic psm1 file, or split the functions out into separate files.  There seems to be a trade
off; keeping the monolithic psm1 file has performance benefits, splitting the files is easier to
modify and maintain.

Splitting the modules and combining them when publishing is the happy middle ground.  A publishing
script can be written which reads all the separate files and appends them to a single psm1 file
which is then shipped.  This allows the module to be organized as a taxonomy which is designed with
humans and maintainability in mind.

Making sure the separate files are combined and tested after the combination process becomes a
critical step in the deployment process.  The result, though, realizes both the benefits of a single
psm1 file and human centric taxonomy.

Ultimately, the module taxonomy is a compromise between computer performance and human readability
for maintenance.  An ideal compromise on those two dimensions can be achieved with complexity on the
dimension of packaging the module.

## Current Taxonomy

This is the current taxonomy I've landed on which is a collection of ideas that have been gathered
from the PowerShell community.  The major components are common and supported by modules that have
been released or adopted and supported by Microsoft.  Dozens of examples with minor variations can
be found by browsing Github.  Figure 1 illustrates the directory structure.

``` bash
|
|_ .vscode
| |_ snippets
| |_ markdown.json
| |_ powershell.json
| |_ launch.json
| |_ README.md
|
|_ docs
|_ ModuleName
| |_ bin
| |_ en-US
| |_ Functions
| | |_ Get-ModuleOption.ps1
| | |_ Initialize-ModuleConfiguration.ps1
| | |_ Write-VerboseProxy.ps1
| |
| |_ lib
|
|_ Tests
| |_ Artifacts
| | |_ config.custom.json
| | |_ config.default.json
| | 
| |_ Functions
| | |_ Get-ModuleOption.Tests.ps1
| | |_ Initialize-ModuleConfiguration.Tests.ps1
| |
| |_ lib
| |
| |_ ModuleName.Test.ps1
|
|_ .gitignore
|_ Invoke-Documentation.ps1
|_ Invoke-Test.ps1
|_ LICENSE
|_ Publish-Module.ps1
|_ README.md
```

### .vscode Directory and Contents

The .vscode directory is included as a default for module projects as the configuration directory
for VSCode.  VSCode has become the ubiquitous editor of choice in the PowerShell community and
including a set of default set of options and snippets will improve contributors' ramp up time.

Launch.json contains a minimal set of options to aid in testing and debugging.

The snippets directory only contains markdown.json and powershell.json.  Markdown.json only contains
a snippet for assisting with creating examples in the PlatyPS Markdown help files.  Powershell.json
contains snippets to assist with project specific forms of new functions and tests that are
different than the general function and test snippets built into the VSCode PowerShell extension.

### docs Directory

This module is initially empty and all files in this directory will be generated by PlatyPS.  The
Invoke-Documentation script will load the module, generate files if they do not exist, or modify any
files as necessary.  The PlatyPS module will identify the command names and parameters, but it is up
to contributors to review and modify placeholder documentation for examples, parameters, and other
help files and descriptions.

Invoke-Documentation compiles this directory into a Microsoft Assistance Markup Language (MAML) file
which is placed in the locale specific help directory in the ...\ModuleName\en-US directory.  Other
locale specific languages can be compiled if desired.  The en-US directory is not included in the
source control repository but is instead created when the module is compiled and deployed.

### Tests Directory

This directory contains all Pest unit test for verifying the functionality of the module.  The basic
structure of the module will mirror the structure of the modules source folder, referred to as
ModuleName in figure 1.

The Artifacts directory will contain any files used for testing, and will generally be mocked
objects generated by the modules or retrieved from mock commands such as Get-ADComputer.

Tests in the root of this directory are for general module operations such as Get-ModuleOption or
Initialize-ModuleConfiguration.  The tests for commands that are exported and tested will be found
in the functions directory with mirrors the location of the code under test in the module.

### ModuleName Directory

This is the module that contains the actual code of the module and is what is packaged and deployed
to the repository for use.  The root of the directory contains the module manifest,
e.g. ModuleName.psd1, and the module file, e.g. ModuleName.psm1.  The psm1 file will only contain
minimal code to load the module and no files.

All functions and commands, both public and private, are contained in the functions directory.  The
functions that will become public, exported commands are specified in the module manifest file, so
there is no need to specify the export command.

Including all functions, public and private, in the same directory simplifies the sourcing,
packaging and and distribution of the module.  At one point I had public and private directories for
the respective function, but found the cognitive burden of locating function was greater than the
benefit of separate directories.  Some people also try different naming conventions for private
functions, e.g. getSomething (camelCase without the '-') for private functions, but again I found
the cognitive burden too great.  Developing a module, all functions function within a module,
private or public, are just that, functions and they can be called with the same name syntax
regardless of location.

The bin and lib directories are similar and will contain external libraries and binaries if needed.

### Root files

- LICENSE - GNU LGPLv3 Preferred per the wiki
- README - Content describing the project, how to get started and contribute
- Invoke-Documentation.ps1 - Calls PlatyPS to generate and update help files in the docs directory
- Invoke-Test.ps1 - Calls Pester to run all tests in the Tests directory
- Publish-Module.ps1 - Publishes the module to a desired repository
- Set-ModuleVersion.ps1 - Was used at one time to set the 4th version octet to the build number,
    but it's no longer used

## Supporting Modules and Components

In order to keep the dependencies as minimal as possible and reduce risk from loss of support, only
3 external module dependencies are used for building and generating the taxonomy and module.  None
of the 3 dependencies are necessary for running or using the resulting module, so it is not
necessary or appropriate to include them in the module manifest as required modules.

The common components supporting the module are PowerShell modules are:

- Plaster - A module which scaffolds new modules base on a tokenized template
- PlatyPS - A module for separating documentation and compiling it into PowerShell MAML help files
- Pester - A unit testing module for PowerShell
